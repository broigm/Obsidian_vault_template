/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PomodoroPlanner
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  pomodoro: 25,
  shortBreak: 5,
  longBreak: 15,
  group: 4,
  includeStats: true,
  includeShortBreak: false,
  includeLongBreak: true
};
var PomodoroPlanner = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "generate-pomodoro-plan",
      name: "Generate",
      editorCallback: async (editor) => {
        await this.loadSettings();
        new GeneratePomodoroPlan(this.app, this.settings, (result) => {
          editor.replaceSelection(result);
        }, () => {
          this.saveSettings(this.settings);
        }).open();
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings(settings) {
    await this.saveData(settings);
  }
};
var GeneratePomodoroPlan = class extends import_obsidian.Modal {
  constructor(app, settings, onSubmit, saveSettings) {
    super(app);
    this.settings = settings;
    const now = new Date();
    this.start = `${now.getHours().toString().padStart(2, "0")}:${now.getMinutes().toString().padStart(2, "0")}`;
    this.onSubmit = onSubmit;
    this.saveSettings = saveSettings;
  }
  generatePomodoroPlan() {
    this.resultMarkdown = "";
    const startTime = parseTime(this.start);
    const endTimeOrCount = parseTimeOrCount(this.end);
    const pomodoro = this.settings.pomodoro;
    const shortBreak = this.settings.shortBreak;
    const longBreak = this.settings.longBreak;
    const group = this.settings.group;
    const includeStats = this.settings.includeStats;
    const includeShortBreak = this.settings.includeShortBreak;
    const includeLongBreak = this.settings.includeLongBreak;
    let currentTime = startTime;
    let groupCount = 0;
    let totalRestTime = 0;
    let pomodoroCount = 1;
    while (willContinue(addMinutes(currentTime, pomodoro), pomodoroCount, endTimeOrCount)) {
      this.resultMarkdown += `- [ ] ${formatTime(currentTime)} - ${formatTime(addMinutes(currentTime, this.settings.pomodoro))} Pomodoro #${pomodoroCount}
`;
      currentTime = addMinutes(currentTime, pomodoro);
      pomodoroCount++;
      groupCount++;
      if (groupCount === group) {
        if (!willContinue(addMinutes(currentTime, longBreak + pomodoro), pomodoroCount, endTimeOrCount))
          break;
        if (includeLongBreak)
          this.resultMarkdown += `- [ ] ${formatTime(currentTime)} - ${formatTime(addMinutes(currentTime, this.settings.longBreak))} Long Break
`;
        currentTime = addMinutes(currentTime, longBreak);
        totalRestTime += longBreak;
        groupCount = 0;
      } else {
        if (!willContinue(addMinutes(currentTime, pomodoro + shortBreak), pomodoroCount, endTimeOrCount))
          break;
        if (includeShortBreak)
          this.resultMarkdown += `- [ ] ${formatTime(currentTime)} - ${formatTime(addMinutes(currentTime, this.settings.shortBreak))} Short Break
`;
        currentTime = addMinutes(currentTime, shortBreak);
        totalRestTime += shortBreak;
      }
    }
    if (pomodoroCount - 1 === 0) {
      this.resultEl.setText("");
      return;
    }
    if (includeStats) {
      const totalWorkTimeHours = Math.floor(pomodoro * (pomodoroCount - 1) / 60);
      const totalWorkTimeMinutes = pomodoro * (pomodoroCount - 1) % 60;
      const totalRestTimeHours = Math.floor(totalRestTime / 60);
      const totalRestTimeMinutes = totalRestTime % 60;
      let info = "\n\n";
      info += `  Total pomodoros: ${pomodoroCount - 1}
`;
      info += `  Total work time: `;
      if (totalWorkTimeHours > 0) {
        info += `${totalWorkTimeHours} hours`;
        if (totalWorkTimeMinutes > 0) {
          info += `, ${totalWorkTimeMinutes} minutes`;
        }
      } else {
        info += `${totalWorkTimeMinutes} minutes`;
      }
      info += `
`;
      info += `  Total rest time: `;
      if (totalRestTimeHours > 0) {
        info += `${totalRestTimeHours} hours`;
        if (totalRestTimeMinutes > 0) {
          info += `, ${totalRestTimeMinutes} minutes`;
        }
      } else {
        info += `${totalRestTimeMinutes} minutes`;
      }
      info += `
`;
      this.resultMarkdown += info;
    }
    if (this.resultEl) {
      this.resultEl.setText(this.resultMarkdown);
      this.saveSettings(this.settings);
    }
    function willContinue(currentTime2, totalPomodoros, endTimeOrCount2) {
      if (typeof endTimeOrCount2 == "number") {
        return totalPomodoros <= endTimeOrCount2;
      }
      return currentTime2 <= endTimeOrCount2;
    }
    function parseTimeOrCount(timeOrCount) {
      if (!timeOrCount) {
        return 0;
      }
      const time = parseTime(timeOrCount);
      if (!isNaN(time.getTime())) {
        return time;
      }
      const count = parseInt(timeOrCount);
      if (!isNaN(count)) {
        return count;
      }
      new import_obsidian.Notice("Invalid time or count format");
      return 0;
    }
    function parseTime(time) {
      const [hours, minutes] = time.split(":").map(Number);
      const now = new Date();
      now.setHours(hours);
      now.setMinutes(minutes);
      return now;
    }
    function addMinutes(time, minutes) {
      const newTime = new Date(time);
      newTime.setMinutes(newTime.getMinutes() + minutes);
      return newTime;
    }
    function formatTime(time) {
      const hours = time.getHours().toString().padStart(2, "0");
      const minutes = time.getMinutes().toString().padStart(2, "0");
      return `${hours}:${minutes}`;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Generate Pomodoro Plan" });
    new import_obsidian.Setting(contentEl).setName("End time or pomodoros count").setDesc("Set end time in HH:MM format or total pomodoros").addText(
      (text) => text.setValue(this.end).onChange((value) => {
        this.end = value;
        this.generatePomodoroPlan();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Starting time").setDesc("The time to start the plan").addText(
      (text) => text.setValue(this.start).onChange((value) => {
        this.start = value;
        this.generatePomodoroPlan();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Pomodoro length (minutes)").setDesc("The length of a pomodoro").addText(
      (text) => text.setValue(this.settings.pomodoro.toString()).onChange((value) => {
        if (!isNaN(parseInt(value))) {
          this.settings.pomodoro = parseInt(value);
          this.generatePomodoroPlan();
        }
      })
    );
    new import_obsidian.Setting(contentEl).setName("Short break (minutes)").setDesc("After each pomodoro finished, a short break will be taken.").addText(
      (text) => text.setValue(this.settings.shortBreak.toString()).onChange((value) => {
        if (!isNaN(parseInt(value))) {
          this.settings.shortBreak = parseInt(value);
          this.generatePomodoroPlan();
        }
      })
    );
    new import_obsidian.Setting(contentEl).setName("Long break (minutes)").setDesc("After each group finished, a long break will be taken.").addText(
      (text) => text.setValue(this.settings.longBreak.toString()).onChange((value) => {
        if (!isNaN(parseInt(value))) {
          this.settings.longBreak = parseInt(value);
          this.generatePomodoroPlan();
        }
      })
    );
    new import_obsidian.Setting(contentEl).setName("Group size (pomodoros)").setDesc("Long break will be taken after each group").addText(
      (text) => text.setValue(this.settings.group.toString()).onChange((value) => {
        if (!isNaN(parseInt(value))) {
          this.settings.group = parseInt(value);
          this.generatePomodoroPlan();
        }
      })
    );
    new import_obsidian.Setting(contentEl).setName("Include short break in plan").addToggle(
      (toggle) => toggle.setValue(this.settings.includeShortBreak).onChange((value) => {
        this.settings.includeShortBreak = value;
        this.generatePomodoroPlan();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Include long break in plan").addToggle(
      (toggle) => toggle.setValue(this.settings.includeLongBreak).onChange((value) => {
        this.settings.includeLongBreak = value;
        this.generatePomodoroPlan();
      })
    );
    new import_obsidian.Setting(contentEl).setName("Include stats in plan").addToggle(
      (toggle) => toggle.setValue(this.settings.includeStats).onChange((value) => {
        this.settings.includeStats = value;
        this.generatePomodoroPlan();
      })
    );
    this.resultEl = contentEl.createEl("pre");
    new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Insert into editor").setCta().onClick(() => {
        if (this.resultMarkdown == "") {
          new import_obsidian.Notice("Please generate the plan first");
          return;
        }
        this.close();
        this.onSubmit(this.resultMarkdown);
      })
    ).addButton(
      (btn) => btn.setButtonText("Copy to clipboard").onClick(() => {
        if (this.resultMarkdown == "") {
          new import_obsidian.Notice("Please generate the plan first");
          return;
        }
        navigator.clipboard.writeText(this.resultMarkdown);
        new import_obsidian.Notice("Copied to clipboard");
      })
    );
    this.generatePomodoroPlan();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
